<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SQL | Documenting all this...]]></title>
  <link href="http://ajonas.herokuapp.com/blog/categories/sql/atom.xml" rel="self"/>
  <link href="http://ajonas.herokuapp.com/"/>
  <updated>2012-10-03T18:01:33-04:00</updated>
  <id>http://ajonas.herokuapp.com/</id>
  <author>
    <name><![CDATA[Adam Jonas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[learn sql the hard way]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/09/26/learn-sql-the-hard-way/"/>
    <updated>2012-09-26T12:53:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/09/26/learn-sql-the-hard-way</id>
    <content type="html"><![CDATA[<p>Schema:</p>

<p>```
♕ sqlite3 ex3.db .schema
/<em> OR </em>/
♕ sqlite3 ex3.db
SQLite version 3.7.7 2011-06-25 16:35:1
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> .schema
CREATE TABLE person (</p>

<pre><code>id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
</code></pre>

<p>```</p>

<p>In the first line I just make ex3.db from the ex2.sql file. Then I add the -echo argument to sqlite3 so that it prints out what it is doing. After that the data is in the database and ready to query.</p>

<p>```
$ sqlite3 ex3.db &lt; ex2.sql
$ sqlite3 -echo ex3.db &lt; ex3.sql
INSERT INTO person (id, first_name, last_name, age)</p>

<pre><code>VALUES (0, "Zed", "Shaw", 37);
</code></pre>

<p>INSERT INTO pet (id, name, breed, age, dead)</p>

<pre><code>VALUES (0, "Fluffy", "Unicorn", 1000, 0); 
</code></pre>

<p>INSERT INTO pet VALUES (1, "Gigantor", "Robot", 1, 1);
```</p>

<p><strong>Important</strong>
Always remember this: SQL ONLY KNOWS TABLES. In programming you deal in graphs and in SQL you deal in tables. They're related concepts, but the mental model is different.</p>

<p>```
/<em> I only want some columns from pet so I am explicit rather than using the '</em>' <em>/
SELECT pet.id, pet.name, pet.age, pet.dead
/</em> To connect person and pet I use the person_pet JOIN table */</p>

<pre><code>FROM pet, person_pet, person
WHERE
    #connect person and pet by the related id columns
    #now the DB can search for only the rows where the ID columns all match
pet.id = person_pet.pet_id AND
    #connect person and person_pet in the same way
person_pet.person.id = person.id AND
    #ask for only the pets that I own
person.first_name = "Adam";
</code></pre>

<p>```</p>

<p><strong>Delete</strong>
DELETE is like SELECT but it removes rows from the table.</p>

<p>```
DELETE FROM pet WHERE id IN (</p>

<pre><code>SELECT pet.id
FROM pet, person_pet, person
WHERE
person.id = person_pet.person_id AND
pet.id = person_pet.pet.id AND
person.first_name = "Zed"
</code></pre>

<p>);</p>

<p>  SELECT * FROM pet;
  SELECT * FROM person_pet;</p>

<p>  DELETE FROM person_pet</p>

<pre><code>  WHERE pet_id NOT IN ( 
      SELECT id FROM pet
  );
</code></pre>

<p>  SELECT * FROM person_pet;
```
The WHERE clause uses an IN to match the id columns in pet to the table that's returned in the subquery. The subquery (also called a subselect) is then a normal SELECT.</p>

<p>How SQL does this is with the following process:
1. Runs the subquery in the parenthesis at the end and build a table with all the columns just like a normal SELECT.
2. Treats this table as a kind of temporary table to match pet.id columns against.
3. Goes through the pet table and deletes any row that has an id IN this temporary table.</p>

<p><em>REPLACE</em>
```
/<em> We can force it by doing an INSERT OR REPLACE. </em>/
INSERT OR REPLACE INTO person (id, first_name, last_name, age)</p>

<pre><code>VALUES (0, 'Frank', 'Smith', 100);
</code></pre>

<p>SELECT * FROM person;</p>

<p>/<em> And shorthand for that is just REPLACE. </em>/
REPLACE INTO person (id, first_name, last_name, age)</p>

<pre><code>VALUES (0, 'Zed', 'Shaw', 37);
</code></pre>

<p>```</p>

<p><em>DROP TABLE</em>
```
  /<em> Only drop table if it exists. Use the IF EXISTS modifier and the table will be dropped only if it's already there. This suppresses the error you get when running you .sql script on a fresh database that has no tables. </em>/
 DROP TABLE IF EXISTS person;</p>

<p>  /<em> Create again to work with it. </em>/
  CREATE TABLE person (</p>

<pre><code>  id INTEGER PRIMARY KEY,
  first_name TEXT,
  last_name TEXT, 
  age INTEGER
</code></pre>

<p>  );</p>

<pre><code>/* Rename the table to peoples. */ 
ALTER TABLE person RENAME TO peoples;

/* Add a hatred column to peoples. */ 
ALTER TABLE peoples ADD COLUMN hatred INTEGER;

/* Rename peoples back to person. */
ALTER TABLE peoples RENAME TO person; 
</code></pre>

<p>  .schema person</p>

<p>  /<em> We don't need that. </em>/
  DROP TABLE person;
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL DB Design]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/09/05/mysql-db-design/"/>
    <updated>2012-09-05T11:51:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/09/05/mysql-db-design</id>
    <content type="html"><![CDATA[<p><a href="http://code.google.com/edu/tools101/mysql.html">MySQL Google</a></p>

<p><em>Data normalization</em>
:  This is the process we go through to develop a design that is free of redundant data and that can be consistently and correctly modified</p>

<p><em>primary keys</em> uniquely identify a record in a table, and <em>foreign keys</em> are used to relate tables
- Every record must have a unique primary key which should not be reused once deleted</p>

<p><em>Referential integrity</em>
:  The data in a foreign key needs to match the primary key in some record of the original table. Referential integrity assures there are no broken links between tables. Note that if you delete a record in the original table, for example, you delete one of the customers from the customer table, referential integrity requires that you delete all references to that customer in the order table.</p>

<h3>MySQL Exercises</h3>

<ol>
<li>Start up MySQL with
<code>
mysql -uroot -ppassword
</code>
Creating a table...
<code>
create table customer (cust_no int not null auto_increment, name varchar(40),
address varchar(40), phone varchar(12), primary key(cust_no));
</code>
"varchar" which means variable-length strings. The numbers following "varchar" in the command above indicate maximum length for the data stored in the field. We also set up cust_no to be the primary key.</li>
</ol>


<p>The orders table...
<code>
create table orders (order_no int not null auto_increment, FK_cust_no int not null,
foreign key(FK_cust_no) references customer(cust_no), primary key(order_no));
</code>
There are only two fields in this table. The order_no field is a primary key, and is an integer, not null and it will auto increment. The cust_no field is a foreign key. We have named it FK_cust_no in the orders table to distinguish it from the cust_no field in the customer table.</p>

<p><em>A foreign key is a field that references a primary key in another table.</em> In the command, we indicate that the FK_cust_no field is a foreign key referencing the cust_no field in customer, indicated by the "foreign key(FK_cust_no) references customer(cust_no)" part of the command. By setting the table up this way, MySQL will enforce constraints-- any order that we enter into the orders table must reference a valid customer in the customer table. If we enter a cust_no in orders that does not exist in customers, an error will result.</p>

<p>A <em>transaction</em> is a sequence of individual database operations that are grouped together. A transaction will never be complete unless each individual operation within the group is successful. If any operation within the transaction fails, the entire transaction will fail. Transactions are a relatively new addition to MySQL but not to relational database systems in general.</p>
]]></content>
  </entry>
  
</feed>
