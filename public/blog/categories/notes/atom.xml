<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: notes | Documenting all this...]]></title>
  <link href="http://ajonas.herokuapp.com/blog/categories/notes/atom.xml" rel="self"/>
  <link href="http://ajonas.herokuapp.com/"/>
  <updated>2012-10-11T17:19:08-04:00</updated>
  <id>http://ajonas.herokuapp.com/</id>
  <author>
    <name><![CDATA[Adam Jonas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HAW-day5]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/08/06/haw-day5/"/>
    <updated>2012-08-06T10:23:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/08/06/haw-day5</id>
    <content type="html"><![CDATA[<p>GOALS:
Refactor code, figure out the jquery ajax checkboxes.
ship v1 by the end of the day</p>

<p><a href="http://khelll.com/blog/ruby/ruby-dynamic-method-calling/">send method</a>
<a href="http://philcrissman.com/2009/06/26/rubys-objectsend-can-call-private-and-protected-methods/">send method to call private method</a></p>

<p>```ruby Code that finally worked...
def self.import_from_airbrake</p>

<pre><code>client = AirbrakeAPI::Client.new

errors = client.errors
actions = {:action =&gt; "action", :controller =&gt; "controller", :created_at =&gt; "airbrake_created_at", 
           :error_class =&gt; "error_class", :error_message =&gt; "error_message", :file =&gt; "file",
           :id =&gt; "airbrake_id", :line_number =&gt; "line_number", 
           :most_recent_notice_at =&gt; "airbrake_most_recent_notice_at", 
           :notice_hash =&gt; "notice_hash", :notices_count =&gt; "notices_count", 
           :project_id =&gt; "project_id", :rails_env =&gt; "rails_env", :resolved =&gt; "airbrake_resolved",
           :search_index_me =&gt; "search_index_me", :updated_at =&gt; "airbrake_updated_at"}

 errors.collect do |error| #each error is a hash
  airbrake_error = AirbrakeError.new #this needs to be outside the following loop or it will create a new object during every loop...
  actions.each do |airbrake_action, our_action| #aa is a sym key, oa is a string value
   airbrake_error.send("#{our_action}=".to_sym, error[airbrake_action])# SEND method here

  airbrake_error.attribute_updater #see below
  end
  airbrake_error.save
end
</code></pre>

<p>  end
<code>
</code>ruby Other use of send...
def attribute_updater</p>

<pre><code>@airbrake_errors = AirbrakeError.all

updater_actions = ["notices_count", "action", "controller", "error_class", "file", "line_number",
                  "airbrake_most_recent_notice_at", "notice_hash", "airbrake_resolved", 
                  "airbrake_updated_at"]

if @airbrake_errors.where(airbrake_id: self.airbrake_id).present?
  original_error = @airbrake_errors.find_by(airbrake_id: self.airbrake_id)

    updater_actions.each do |action|
      original_error.send("#{action}=".to_sym, self["#{action}".to_sym])
      original_error.save
    end
else     
end
</code></pre>

<p>  end
```</p>

<p>TODO:
inject method</p>

<p>Per Dave:
-one form that is ignore, one that signal, one that is the tags
-remote true- a flag that going to submit the form via ajax</p>

<p><a href="http://guides.rubyonrails.org/form_helpers.html">Remote True:</a>
Unlike other forms making an asynchronous file upload form is not as simple as providing form_for with :remote => true. With an Ajax form the serialization is done by JavaScript running inside the browser and since JavaScript cannot read files from your hard drive the file cannot be uploaded. The most common workaround is to use an invisible iframe that serves as the target for the form submission.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HAW-day3]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/08/02/haw-day3/"/>
    <updated>2012-08-02T10:55:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/08/02/haw-day3</id>
    <content type="html"><![CDATA[<p>Rolled back git using the sha</p>

<p>used the fresh method to collect the fresh errors in an array. then we used the flatten method to un-nest the array to acccess the objects.</p>

<p>changed the interface to show the airbrake IDs so that we can differentiate the errors with the same name</p>

<p>p291
form_tag issues an HTTP request that replaces all the content in the browser.
form_remote_tag issues an HTTP request, but processes the results with JavaScript
rather than having the browser render them directly.</p>

<p>nav
filtering
all errors inbox
checkboxes(which don't work but do display) - have the route for signal</p>

<p>event driven programming</p>

<p>dom fields</p>

<p>cmd option i - to open the</p>

<p>collect all values
submit the request, submit the values manually
raise params.inspect</p>

<p>GOAL OF THE IMPORTER:
import a new set of airbrake errors</p>

<p>if the id is NOT uniq then update the attributes but do not display or save in mongoid memory</p>

<p>identify what is uniq with the present method
if uniq ignore
if NOT uniq then update attributes
makes sure the newly imported error will not save --> validation should take care of this</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[haw-day1]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/07/31/haw-day1/"/>
    <updated>2012-07-31T15:15:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/07/31/haw-day1</id>
    <content type="html"><![CDATA[<h3>Deploying to Heroku</h3>

<p>Make sure to modify the <a href="https://devcenter.heroku.com/articles/mongohq#mongoid">mongoid.yml file</a> to config the production environment.</p>

<p><strong><em>2 major issues with the mongoid deploy:</em></strong></p>

<ol>
<li>Issue with ruby version was the first error we encountered... need to keep in that <em>mongoid only supports 1.9.3</em> this ended up being a big issue.</li>
</ol>


<p>In --> heroku logs --tail:
<code>
ActionView::Template::Error (undefined method `[]' for nil:NilClass):
 11:   &lt;/thead&gt;  
 10:     &lt;/tr&gt;
 12:
 13:   &lt;% @airbrake_errors.each_with_index do |a_e, index| %&gt;
</code></p>

<ol>
<li>The other issue was to reconfigure the setting below from false to true as the</li>
</ol>


<p><code>ruby config/environments/production.rb
 config.assets.compile = true
</code></p>

<p>```
 ActionView::Template::Error (images/apple-touch-icon-144x144-precomposed.png isn't precompiled):</p>

<p> &lt;%= favicon_link_tag 'images/apple-touch-icon-144x144-precomposed.png', :rel => 'apple-touch-icon-precomposed', :type => 'image/png', :sizes => '144x144' %></p>

<p> app/views/layouts/application.html.erb:19:in `<em>app_views_layouts_application_html_erb</em>__1957659516384225917_21931620'
```</p>

<h3>Rewriting the writer</h3>

<p>```ruby Change the tag writer
def tag_names=(string_of_names)</p>

<pre><code>string_of_names.split(", ").each do |tag_name|
  self.tags.find_or_create_by(name: tag_name)
  #the find_or_create_by wasn't creating unique tag names
  #the reason was because we were linking too many methods together
  #mongoid is finicky
end
</code></pre>

<p>  end</p>

<h1>was changed to...</h1>

<p>def tag_names=(string_of_names)</p>

<pre><code>self.tags &lt;&lt; string_of_names.split(", ").collect do |tag_name|
  tag = Tag.find_or_create_by(name: tag_name)
end
</code></pre>

<p>  end</p>

<h1>but we discoved that the tags were no disappearing if they were left off the form</h1>

<p>def tag_names=(string_of_names)
   #later we added this line because tags were persisting even if we tried to edit them.</p>

<pre><code>self.tags.delete_all
self.tags &lt;&lt; string_of_names.split(", ").collect do |tag_name|
  tag = Tag.find_or_create_by(name: tag_name)
end
</code></pre>

<p>  end
<code>
</code>ruby the last td was changed...
 &lt;% @airbrake_errors.each_with_index do |a_e, index| %></p>

<pre><code>&lt;tr&gt;
  &lt;td&gt;
    &lt;%= a_e.tags.collect{ |tag|
        link_to(tag.name, tag_path(tag)) #=&gt; "&lt;a href="adasda"&gt;Tag&lt;/a&gt;"
    }.join(", ").html_safe %&gt;
    &lt;/td&gt;
    # this needs to be better understood-- TODO
</code></pre>

<p>```</p>

<h3>HTTP Authentication</h3>

<p><a href="http://stackoverflow.com/questions/3839167/is-there-a-way-to-set-up-simple-http-authentication-for-an-app-on-heroku">This did it</a>.</p>

<h3>Pushing the seed file to heroku</h3>

<p><code>
â™• heroku run rake db:seed
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HAW- Day0]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/07/30/haw-day0/"/>
    <updated>2012-07-30T10:13:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/07/30/haw-day0</id>
    <content type="html"><![CDATA[<p>Pivotal:
Move from icebox to current
Click Start
Each story is either a feature, a bug, or a chore</p>

<p>Generate our app
Some sort of layout
beginning data model
- main model
- tag model
Import script to retreive that data off the API</p>

<p>Views/Controllers
- index view
- tagging</p>

<p>Keep commits small and never develop in the master branch</p>

<p>Git:
Git create the repo
git clone the repo
git merge mongoid-setup --no-ff #no FF- will show the branch even after the commmit</p>

<p>Mongoid-
rails new myapp -O (--skip-active-record)
<code>
gem 'mongoid', "~&gt; 3.0.0"
</code></p>

<p>Twitter Bootstrap
gem twitter-bootstrap</p>

<p>Airbrake Gem</p>

<p>Powder Gem
gem install powder
makes app available at airbrake.dev</p>

<p>Immediately want to start creating the 'error model', but error is a terrible title so call it airbrake model</p>

<p>Routes:
change index to errors#index</p>

<p>Generate airbrake_errors model
Generate errors_controller
Generate bootstrap
<code>ruby Fluid Layout
rails g bootstrap layout application fluid
</code>
<code>ruby In Console
AirbrakeError.create(:name =&gt; "Test")
</code></p>

<p>in the test unit, want to check that AirbrakeError.delete_all
test to make sure the airbrake API gem tried to connect</p>

<p><code>ruby
def AirbrakeError.import_from_airbrake
</code></p>

<p>Create initializer to config the connection to airbrake</p>

<h3>Next Steps</h3>

<p>build out the bootstrap layout
build the import script</p>

<p>Ruby Debugger: TODO
gem debugger at the bottom of the gem file
bundle</p>

<p>inspect the hashiemashie to see how the objects are composed</p>

<p><code>ruby
def self.import_from_airbrake
  a = AirbrakeAPI::Client.new
end
</code></p>

<p>Airbrake Doc:
Can make calls to get a list of errors in general and a call to get more info about an error.
-The api in general isn't all that detailed.</p>

<p>There is a diff between .error('id') and .errors -- the difference is in what is returned-- i.e. the backtrace etc.</p>

<p>check out what notices because we are probably interested more in the notice than the error itself.</p>

<p><code>ruby Maybe Something Like This?
def ignore
  AirbrakeAPI.update(self.id, :group =&gt; { :resolved =&gt; true})
end
</code></p>

<p>Diff between error and notice: an error is a unique conceptual item and a notice is the occurance of the error</p>

<p>```ruby
h = {:a => 1}
  h.each do |k,v|
  end
b[k] = v</p>

<h1>this is the same as the dynamic dispatching method</h1>

<p>airbrake.send("#{key}=", value)
```</p>

<p>From there let's go to the view and start formatting the output</p>

<p>Ruby alias method-- this is built into ruby not rails or mongoid
<code>ruby airbrake_error.rb
alias :name :error_message
</code></p>

<p>TIPS and Tricks section:
Gem Server shows the documentation locally</p>

<p><a href="http://www.codinghorror.com/">Jeff Atwood</a></p>

<p>LOOK-UP 'Client', 'tap', 'send'
dynamic dispatch and the send method
rails cycle
Moped::BSON: -- how it generates its unique IDs</p>

<p>GIT STUFF:
<code>
git pull --rebase #=&gt; if the remote has merges, rewind and then move back forward
git reset --hard HEAD #=&gt; go to the last checkout (HEAD of the branch) without the warnings (hard)
git stash # save changes
git stash pop #restore changes
</code></p>

<p><code>
â™• git add .
â™• git status
â™• git checkout -b link-to-airbrake
M   app/models/airbrake_error.rb
M   app/views/errors/index.html.erb
Switched to a new branch 'link-to-airbrake'
â™• git add .
â™• git commit -am "added airbrake_url method and link_to in views"
â™• git push
â™• git checkout master
â™• git merge link-to-airbrake
â™• git push
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lecture 3- July 15]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/07/16/lecture-3-july-15/"/>
    <updated>2012-07-16T16:06:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/07/16/lecture-3-july-15</id>
    <content type="html"><![CDATA[<p><strong><em>Rails Lecture 3- July 15</em></strong></p>

<p>why use 'get' instead of 'match' in the routes file?
-bc want to use http verbs to be more specific
-match is more vague, you should generally use specific verbs</p>

<p><code>
rake routes CONTROLLER=SESSIONS
</code>
will narrow output</p>

<p>```
render :action => 'under_construction' #=> relative to the current controller
render :template => 'shared/under_construction' #=> doesn't assume it is in the current views folder</p>

<h1>under the class name</h1>

<p>render 'shared/under_construction' #=> these 3 work the same now
```</p>

<p><strong>Private Methods</strong>(2:40)
- about what object the receiver is on the method called-- private methods can only be called on implicit receivers
- a way to control scope
- anything that is not an action, that isn't an endpoint of a route should be private</p>

<p>routes: bridge between the browser, specifcially URLs, and the app</p>

<p>Polymorphic Interface(2:50)
The link_to method--> accepts two parameters. the first is the name of the link as a string, the second is the string that it just uses it as a href
-> if I send it an instance of active record, it's behavior will change ==> it will become intelligent and it will understand that it is an instance of active record</p>

<p><strong>Lecture</strong> (2:55)</p>

<p>anything that starts with an underscore '_form.erb.html' for example is a snippet of code that is reused on multiple templates</p>

<p>form_for(@song) --> knows whether the song is new or should be updated... obviously different verbs are required for those diff actions</p>

<p><code>ruby Form Helpers (3:09)
form_for(@song)
f.textfield :artist_name #=&gt; this will break if there is not a artist_name method for the song class in the controller
</code></p>

<p>``` ruby
def create</p>

<pre><code>@song = Song.new(param[:song]) 
# this line instantiates a New Song
# collects the data
#assigning the data to the correct attribute
</code></pre>

<p> #the params[:song] lines does the last two steps
end
```</p>

<p><strong>Params</strong> (3:20)
params looks and behaves like a hash
its a nested hash</p>

<p>``` ruby Assigning a name
@song.name = params[:song][:name] #but this happens during the following line of code:</p>

<p>@song = Song.new(param[:song]) # this happens using mass assignment!
```</p>

<p><code>ruby Manually Assigning the Name
input type ="text" name="song[name]" #this looks like the key of the params hash ==&gt; params[:song][:name]
</code></p>

<p>(3:50) Nested hash testing</p>

<p><code>ruby Query string (3:57)
mldraft.com?person[name]=adam&amp;person[email]=adam@mldraft.com
</code>
Can access the params hash in the same way as the form. So params[:person][:name] will equal adam</p>

<p>Mass Assignment Vulnability (4:05)
- attr_accessible is a whitelist approach versus attr_protected which is a black list approach
- this has nothing to do with the attr_accessor, reader, or writer</p>

<p>Virtual attributes don't persist to the database</p>
]]></content>
  </entry>
  
</feed>
