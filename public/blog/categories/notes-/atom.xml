<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: notes, | Documenting all this...]]></title>
  <link href="http://ajonas.heroku.com/blog/categories/notes-/atom.xml" rel="self"/>
  <link href="http://ajonas.heroku.com/"/>
  <updated>2012-07-08T18:08:58-04:00</updated>
  <id>http://ajonas.heroku.com/</id>
  <author>
    <name><![CDATA[Adam Jonas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Octopress]]></title>
    <link href="http://ajonas.heroku.com/blog/2012/07/05/octopress/"/>
    <updated>2012-07-05T10:54:00-04:00</updated>
    <id>http://ajonas.heroku.com/blog/2012/07/05/octopress</id>
    <content type="html"><![CDATA[<p>Follow directions here...</p>

<p>Setting Up Octopress</p>

<p><a href="http://octopress.org/docs/setup/">http://octopress.org/docs/setup/</a></p>

<p>Had one hiccup in my system didn't have Ruby 1.9.2 which .rvmrc file requires (https://rvm.io//workflow/rvmrc/). I had to go ahead and install it.</p>

<p>Deploying on Heroku:</p>

<p>To see on localhost:4000
rake preview</p>

<p><strong>To push:</strong>
<code>
rake generate
git add .
git commit -m 'site updated'
git push heroku master
</code></p>

<p><a href="http://octopress.org/docs/deploying/heroku/">Octopress delpoy instructons</a></p>

<p>That all went fairly well... though I didn't understand all the intermediate steps. I'll have to take closer look.</p>

<p><a href="http://support.mashery.com/docs/customizing_your_portal/Markdown_Cheat_Sheet/">Markdown language cheat sheet</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Procs and lambdas]]></title>
    <link href="http://ajonas.heroku.com/blog/2012/07/03/procs-and-lambdas/"/>
    <updated>2012-07-03T10:53:00-04:00</updated>
    <id>http://ajonas.heroku.com/blog/2012/07/03/procs-and-lambdas</id>
    <content type="html"><![CDATA[<p>You know how everything in Ruby is an object, well, as it turns out that's not quite true. Ruby blocks are not objects! So, blocks are not objects, but you can turn them into objects without too much trouble. We do this by wrapping our block in an instance of the Proc class...
PROCS:</p>

<p>Very standard to pass along a code block to the each method</p>

<p>block_given? --> method to check whether a block was given to a method or not</p>

<p>A proc --> a nameless or anonymous block of code that can be represented as an object, can be passed around and called at will</p>

<p>``` ruby E.G.
class Array
def random_each(&amp;b)  # => with the ampersand, b essentially becomes a reference to the code block below.
  shuffle.each do |el|</p>

<pre><code>b.call el  #=&gt; b is a proc
end
</code></pre>

<p>  end
end</p>

<p>[1,2,3,4,5].random_each do |el|
puts |el|</p>

<p>end
```
You can only pass a single block to a method at one time, but you can pass multiple procs around because they are regular object like arrays or strings.</p>

<p>``` ruby E.G.
Def run_two_procs (a, b)
  a.call
  b.call
end</p>

<p>proc1 = Proc.new do
puts "This is proc1"
end</p>

<p>proc2 = Proc.new do
puts "This is proc2"
end</p>

<p>run_two_procs proc1, proc2
```
If you have a code block, you can call it with yield, you can use the ampersand argument to convert it into a proc,</p>

<p>**if you use Proc.new without giving it a code block to assign to that Proc, Proc.new will look to see if the current scope has been passed a code block and then it will use that --> it will do it all implicitly, you don't need to specify anything here. If it can't find a block (e..g if you commented the block below) it raises an error. Proc.new wants a block passed directly or it implicitly picks it up from the current scope/environment.</p>

<p>``` ruby
Def run_block
  p = Proc.new # **see above
  p.call
end</p>

<p>run_block do
puts "Hello World'</p>

<p>end
```</p>

<p>In Ruby 1.9 there are 4 main ways to run or call a block:
``` ruby Proc e.g.
my_proc = Proc.new do |a|
  puts "This is a proc and #{a} was passed along to me"
my_proc.call(10) #call method that passes in 10
my_proc.(20) #this isn't a typo, gets converted to a call
my_proc[30] #
my_proc === 40 # triple equal is called the case equality operator, it's primary function is used in case statements</p>

<p>several = Proc.new { |number| number > 3 &amp;&amp; number &lt; 8 }
none = Proc.new { |number| number == 0 }</p>

<p>case number
when several
  puts "several"
when none
  puts "none"
end
```
-->In this case the several proc is being run and if it returns true it runs the puts --> this abstracts everything away</p>

<p><strong><em>Lambdas</em></strong></p>

<p>Lambdas are much more sensitive than Procs to parameters. Much like methods, they need to receive the exact number of arguments as defined. Procs will just grab nil if nothing has been passed in.
Closures</p>

<p>In ruby a closure is like an anonymous code block, but that maintains references to local variables and were being used at the time of the definition of that code.
``` ruby
def run_proc(p)
  p.call
end</p>

<p>name = "Fred"</p>

<p>print_a_name = proc { puts name } # this name doesn't exist in the definition above. This magic is called a closure. (23 Min)</p>

<p>run_proc print_a_name
```</p>

<p>ALSO:
``` ruby
def run_proc(p)
  p.call
end</p>

<p>name = "Fred"
print_a_name = proc { puts name }
name = "John"</p>

<p>run_proc print_a_name # => now this will output John because it kept a reference to the local variable.
```
<a href="http://www.youtube.com/watch?v=VBC-G6hahWA">Video</a></p>

<p><a href="http://www.ruby-doc.org/core-1.9.3/Proc.html">DOCUMENTATION</a></p>

<p>SOME MORE READING:</p>

<p><a href="http://www.skorks.com/2010/05/ruby-procs-and-lambdas-and-the-difference-between-them/">http://www.skorks.com/2010/05/ruby-procs-and-lambdas-and-the-difference-between-them/</a></p>

<p><a href="http://pine.fm/LearnToProgram/?Chapter=10">http://pine.fm/LearnToProgram/?Chapter=10</a></p>

<p><a href="http://strugglingwithruby.blogspot.com/2009/02/ruby-proc.html">http://strugglingwithruby.blogspot.com/2009/02/ruby-proc.html</a></p>

<p><a href="http://pragdave.blogs.pragprog.com/pragdave/2008/09/fun-with-procs.html">http://pragdave.blogs.pragprog.com/pragdave/2008/09/fun-with-procs.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The tap method]]></title>
    <link href="http://ajonas.heroku.com/blog/2012/07/02/the-tap-method/"/>
    <updated>2012-07-02T10:52:00-04:00</updated>
    <id>http://ajonas.heroku.com/blog/2012/07/02/the-tap-method</id>
    <content type="html"><![CDATA[<p>I haven't found great explanations for this yet but there is a video below... prety much the tap method allows you to initialize methods right off the bat.</p>

<p>The tap method is available to all Ruby objects and serves as a way to have a block "act on" the method's caller and return the object called. Per the Ruby docs, "the primary purpose of this method is to 'tap into' a method chain, in order to perform operations on intermediate results within the chain". For some examples on using tap see MenTaLguY's post on Eavesdropping on Expressions. As he says in his post, "you can insert your code just about anywhere without disturbing the flow of data."</p>

<p>I'm having some trouble following all this... Matt Stopa has a video below that is more for a beginner.</p>

<p><a href="http://www.youtube.com/watch?v=QAJMxBkYaUQ">The video is here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lecture 2 Ruby Lecture Video Notes]]></title>
    <link href="http://ajonas.heroku.com/blog/2012/06/10/lecture-2-ruby-lecture-video-notes/"/>
    <updated>2012-06-10T10:37:00-04:00</updated>
    <id>http://ajonas.heroku.com/blog/2012/06/10/lecture-2-ruby-lecture-video-notes</id>
    <content type="html"><![CDATA[<p>Programmer _Why
-We don't speak machine. Coders are not translators. We need to teach the machine to speak like us.</p>

<p>There shouldn't be anything in code that you don't understand.
-Code is composed of the language, the name that you give things
-The language is just a bunch of keywords that have reserved meaning (10 min)- you can't use them for anything else</p>

<p>Names
-Varaiables- store references to things. (they are lowercase and are previously undefined)- they are pointers/make references to data
"The beginning of wisdom is calling things by its right name"
Data- literals
strings- indicate that the following characters should not be interpretted as code, but are rather just pieces of data (13min)</p>

<p>=> comment followed by hash rocket means 'should return'
(TIP- control L clears your terminal window)</p>

<p>Going over the quiz (14 min)</p>

<p>ruby -c --> ruby c flag, checks to the see if the program even works</p>

<p>When I debug code, it is a forensic process</p>

<p>Read code outloud</p>

<p>def is a keyword
ArgumentError is raised the wrong number of parameters are passed to a method
NameError occurs when Ruby encounters a word that was previously undefined- like an english word
Synatax error occurs when something you submitted breaks the compiler- like a floating plus sign</p>

<p>mate cmd r runs the code
subl cmd b runs the code
Comparisons (28 min):</p>

<p>true and false are the atoms of programs, they are the protons and electrons of the universe</p>

<p>(33 min) the single equal are reserved for assignment and the double equals are for comparison
"test" == "TEST" is false
!= is the not equal operator
--> these allow us to evaluate whether something is true or false</p>

<p>(36min) escape character \ e.g.
"
\"In the beginning.."
"</p>

<p><strong><em>Branching</em></strong> (38 min)
if, else, end branch (39 min)
- the moment it encounters a truth, it is going to stop running the branches
every if statement does not require an else clause</p>

<p>in ruby everything is an expression, which means that everything must evaluate into a return value so you can even use if statements as an expression in itself (42 min)
if statement assignment- we are using an if statement to control the value of a variable</p>

<p>elsif (45 min)
every branch of an if statement operates independently of the other branches. therefore you can evaluate if x... elsif y... it doesn't matter</p>

<p>it's always going to boil down to one value-- even if it is 6 or 7 lines of code in the end it can only equal one thing -- expressions however are composed of subexpressions-- that the basis of compositon (49 min)</p>

<p>-also have the unless keyword -- which is the converse of the if keyword-- this isn't preferred-- prefer the negation usually</p>

<p><strong><em>Logic</em></strong> (50 min)
- once we have true and false, and we have expressions (like 1 &lt; 2), and we have if statments then we have all the ingredients for logical equations</p>

<p><strong><em>the OR operator ||</em></strong>
<code>ruby
x = 2
if (x/2 == 1) || (x == 1) # as long as one of the expressions evaluates to true, it passes
</code></p>

<p>The only thing that evaluates to false is nil (absence of expression) and false</p>

<p>0 is true, 4 is true, "string" is true
x = false || 4 --> this will return 4 -->> this will assign x to 4</p>

<p>x = 1 || 2 #--> x will equal one because the moment it encounters a true statement it stops executing the rest of the code</p>

<p><strong><em>the AND operator &amp;&amp;</em></strong>
for an AND operator to be true, both sides of the equation must be true
so y = false &amp;&amp; puts 'hello' --> it will not even get to the puts statement because once it encounters the false it stops evaluating the expressions</p>

<p>negation operator !
<strong><em>SWITCHING</em></strong>
(1 hr 4min)- switching between conditions
if statement can get verbose and confusing and sometimes they aren't good for checking multiple related conditions</p>

<p>case x
when, else, end
unlike an if statement, a case statement is locked to the object you send it
e.g. case x
x == 1
y == 4 #this will be compared to x</p>

<p>you can combine &amp;&amp; and || operators.
<code>ruby
x = 1 if 1 &lt; 2 #=&gt; x = 1
x = 1 if 2 &lt; 1 #=&gt; nil (1 hr 16 min)
</code>
PART 2 Video
Running through the exercises</p>

<p>(10 min)
``` ruby
q = "a"
when q.downcase == "a" #=> this is eval as false.
puts "its a vowel"</p>

<p>q = "a"
when "a"
puts "it's a vowel" #=> this is the way to do it
```</p>

<p><strong><em>LOOPING</em></strong> (12min 30 sec)
if statements and case statements area how we control flow so that the program is not just stupidly linear - we can have conditions and ambiguity
another way to do this with loops
-the simpliest loop is with the while keyword
- it is check a condition or expression and until that expression evaluates to true it will run that code</p>

<p>``` ruby
x = 1</p>

<p>while x &lt; 10
  puts x
  x += 1 #=> will increment x by 1. just like x = x + 1
end
```</p>

<p>the break keyword will exit the current loop --> 23 min</p>

<p>if I have an unexpected end -- you have a dangling end, but you often don't know where... this is why indentation is so important</p>

<p>tabs are meaningful characters and spaces aren't -- use spaces for indentation NOT tabs</p>

<p>until -- is the converse of the while loop-- we don't like until loops as much as while</p>

<p>-also have the until keyword -- until x == 1 is the same as while x != 1 #=> this isn't preferred, usually like the negation of while-- in some situations it is appropriate. unless and until are the safron of keywords. Use them sparingly!!</p>

<p>->encountered 5 types thus far--> strings, intergers, floats, nil and false</p>

<p><strong><em>ARRAYS</em></strong>- (26min)-- an indexed collection of objects-- a type to hold other values
the literal for an array is []
- if you miss a comma [1, 2 3]--> you will get a syntax error
- for array [1, 2, 3][0]--> this indexes the first slot. Remember that it states counting at the zero element
-accessing a position in an array (33 min)</p>

<p>puts days_of_the_week[(days_of_the_week.size-1)] #=> will return the 6th element
weekdays = days_of_the_week[1, 5] --> this is a range of position one to five</p>

<p>arrays in Ruby are elastic (52 min)
<code>ruby
a = [[1, 2], "a"]
a[0] # =&gt; [1,2]
a[0][1] =&gt; 2
</code>
<strong><em>RECEIVERS</em></strong> (55 min)
-Ruby is an object oriented language so that means that everything is an object. We interact with objects by sending them methods using methods</p>

<p>slice(0,2) # => this slices out the first 3 elements
concat("uth") # => this appends "uth" to the end</p>

<p>chomp and slice are out periodic elements (1hr 8 min)</p>

<p><strong><em>STRING METHODS:</em></strong>
strip gets rid of both leading and trailing spaces
lstrip - rid of leading spaces
tstrip - trailing spaces</p>

<p>puts "of Least Surprise".insert[0, "Principle"] => inserts Principle at position 0</p>

<p>gsub (1hr 16min)- global substitution - takes two arguments (the pattern, the replacement value)</p>

<p><strong><em>Booleans-</em></strong>
puts"".empty? #=> true
put " ".empty? #=> false</p>

<p>eql?, starts_with?, include?</p>

<p><strong><em>Return Methods</em></strong> (1hr 18min)-
to_i
size
next --> next thing in a sequence. puts "a".next # => "b"</p>

<p>puts "one, two".slice(0,3) #=> one --> start at position one and give me 3 characters</p>

<p>match --> the first occurance of the match
scan --> scan will return all occurances --> returns an array of objects</p>
]]></content>
  </entry>
  
</feed>
