<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lecture | Documenting all this...]]></title>
  <link href="http://ajonas.heroku.com/blog/categories/lecture/atom.xml" rel="self"/>
  <link href="http://ajonas.heroku.com/"/>
  <updated>2012-07-06T15:23:05-04:00</updated>
  <id>http://ajonas.heroku.com/</id>
  <author>
    <name><![CDATA[Adam Jonas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Collections and Enumerators â€“ David Black]]></title>
    <link href="http://ajonas.heroku.com/blog/2012/06/26/ruby-collections-and-enumerators-david-black/"/>
    <updated>2012-06-26T10:49:00-04:00</updated>
    <id>http://ajonas.heroku.com/blog/2012/06/26/ruby-collections-and-enumerators-david-black</id>
    <content type="html"><![CDATA[<p>Ruby Collections and Enumerators
David Black
June 26, 2012</p>

<p>Enumerators
- what is an enum?
- an instance of class Enum
-external iterator
-iterates via a specific method on an underlying object</p>

<p>??next method- walk through the iteration and give you the next value</p>

<p>the default bound is the each method
%w --> converst to enum</p>

<p>loop resuces the stop Iteration error
??each_cons method
if you run each on enum = array.map # => it behaves like map
same with array.select and array.each_cons</p>

<p>Can also chain enumerators:</p>

<p>array.each.with_index #=> will yield the index
array.map.with_index</p>

<p>String Enumerables
-bytes (aka each_byte)
-chars (aka each_char)
-lines (aka each_line)</p>

<p>count takes a block (how many is this true for...)</p>

<p>?? diff between take and select
ENUM METHODS:
.extend(Enumerable) #=> extends the Enum functionality if operating on a single object</p>

<p>each_slice doesn't overlap like each_cons</p>

<p>There is a Prime class (require 'prime')</p>

<p>array.any? --> is there anything True in this array?
array.none?
array.one? (just one-- will exit after it's first hit)
array.all?</p>

<p>array = [a,3,2,4,5,6,7]
array.partition {block that calls the even method} #=> wtih divide the result into two arrays a true an other
array.slice_before #=> [[1,3], [2], [4,5,7], [6]]
chunk discards results for which the block evaluates to nil #=> not useful- obscure method
array.take
array.drop</p>

<p>take_while #=> e.g. while true execute below
drop_while</p>

<p>array = [1,2,3]
array.permutation.to_a # => yields all the permuatations of the array [[1,2,3], [1,3,2], [2,1,3]]
array.combination(2).to_a #=> yields the combinations (in this case 2 at a time [1,2], [1,3], [2,3])</p>

<p>array.sample #=> pulls a random sample from the array
array.shuffle # => will randomize the sample</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lecture 2 Ruby Lecture Video Notes]]></title>
    <link href="http://ajonas.heroku.com/blog/2012/06/10/lecture-2-ruby-lecture-video-notes/"/>
    <updated>2012-06-10T10:37:00-04:00</updated>
    <id>http://ajonas.heroku.com/blog/2012/06/10/lecture-2-ruby-lecture-video-notes</id>
    <content type="html"><![CDATA[<p>Programmer _Why
-We don't speak machine. Coders are not translators. We need to teach the machine to speak like us.</p>

<p>There shouldn't be anything in code that you don't understand.
-Code is composed of the language, the name that you give things
-The language is just a bunch of keywords that have reserved meaning (10 min)- you can't use them for anything else</p>

<p>-Names
-Varaiables- store references to things. (they are lowercase and are previously undefined)- they are pointers/make references to data
"The beginning of wisdom is calling things by its right name"
Data- literals
strings- indicate that the following characters should not be interpretted as code, but are rather just pieces of data (13min)</p>

<p>=> comment followed by hash rocket means 'should return'
(TIP- control L clears your terminal window)</p>

<p>Going over the quiz (14 min)</p>

<p>ruby -c --> ruby c flag, checks to the see if the program even works</p>

<p>When I debug code, it is a forensic process</p>

<p>Read code outloud</p>

<p>def is a keyword
ArgumentError is raised the wrong number of parameters are passed to a method
NameError occurs when Ruby encounters a word that was previously undefined- like an english word
Synatax error occurs when something you submitted breaks the compiler- like a floating plus sign</p>

<p>mate cmd r runs the code
subl cmd b runs the code
Comparisons (28 min):</p>

<p>true and false are the atoms of programs, they are the protons and electrons of the universe</p>

<p>(33 min) the single equal are reserved for assignment and the double equals are for comparison
"test" == "TEST" is false
!= is the not equal operator
--> these allow us to evaluate whether something is true or false</p>

<p>(36min) escape character \ e.g.
"
\"In the beginning.."
"</p>

<p>Branching (38 min)
if, else, end branch (39 min)
- the moment it encounters a truth, it is going to stop running the branches
every if statement does not require an else clause</p>

<p>in ruby everything is an expression, which means that everything must evaluate into a return value so you can even use if statements as an expression in itself (42 min)
if statement assignment- we are using an if statement to control the value of a variable</p>

<p>elsif (45 min)
every branch of an if statement operates independently of the other branches. therefore you can evaluate if x... elsif y... it doesn't matter</p>

<p>it's always going to boil down to one value-- even if it is 6 or 7 lines of code in the end it can only equal one thing -- expressions however are composed of subexpressions-- that the basis of compositon (49 min)</p>

<p>-also have the unless keyword -- which is the converse of the if keyword-- this isn't preferred-- prefer the negation usually</p>

<p>Logic (50 min)
- once we have true and false, and we have expressions (like 1 &lt; 2), and we have if statments then we have all the ingredients for logical equations</p>

<p>the OR operator ||
x = 2
if (x/2 == 1) || (x == 1) -- as long as one of the expressions evaluates to true, then it passes</p>

<p>The only thing that evaluates to false is nil (absence of expression) and false</p>

<p>0 is true, 4 is true, "string" is true
x = false || 4 --> this will return 4 -->> this will assign x to 4</p>

<p>x = 1 || 2 --> x will equal one because the moment it encounters a true statement it stops executing the rest of the code</p>

<p>the AND operator &amp;&amp;
for an AND operator to be true, both sides of the equation must be true
so y = false &amp;&amp; puts 'hello' --> it will not even get to the puts statement because once it encounters the false it stops evaluating the expressions</p>

<p>negation operator !
SWITCHING (1 hr 4min)- switching between conditions
if statement can get verbose and confusing and sometimes they aren't good for checking multiple related conditions</p>

<p>case x
when, else, end
unlike an if statement, a case statement is locked to the object you send it
e.g. case x
x == 1
y == 4 #this will be compared to x</p>

<p>you can combine &amp;&amp; and || operators.</p>

<p>x = 1 if 1 &lt; 2 #=> x = 1
x = 1 if 2 &lt; 1 #=> nil (1 hr 16 min)</p>

<p>PART 2 Video
Running through the exercises</p>

<p>(10 min)
q = "a"
when q.downcase == "a" #=> this is eval as false.
puts "its a vowel"</p>

<p>q = "a"
when "a"
puts "it's a vowel" #=> this is the way to do it</p>

<p>LOOPING (12min 30 sec)
if statements and case statements area how we control flow so that the program is not just stupidly linear - we can have conditions and ambiguity
another way to do this with loops
-the simpliest loop is with the while keyword
- it is check a condition or expression and until that expression evaluates to true it will run that code</p>

<p>x = 1
while x &lt; 10
puts x
x += 1 #=> will increment x by 1. just like x = x + 1
end
the break keyword will exit the current loop --> 23 min</p>

<p>if I have an unexpected end -- you have a dangling end, but you often don't know where... this is why indentation is so important</p>

<p>tabs are meaningful characters and spaces aren't -- use spaces for indentation NOT tabs</p>

<p>until -- is the converse of the while loop-- we don't like until loops as much as while</p>

<p>-also have the until keyword -- until x == 1 is the same as while x != 1 #=> this isn't preferred, usually like the negation of while-- in some situations it is appropriate. unless and until are the safron of keywords. Use them sparingly!!</p>

<p>->encountered 5 types thus far--> strings, intergers, floats, nil and false</p>

<p>ARRAYS- (26min)-- an indexed collection of objects-- a type to hold other values
the literal for an array is []
- if you miss a comma [1, 2 3]--> you will get a syntax error
- for array [1, 2, 3][0]--> this indexes the first slot. Remember that it states counting at the zero element
-accessing a position in an array (33 min)</p>

<p>puts days_of_the_week[(days_of_the_week.size-1)] #=> will return the 6th element
weekdays = days_of_the_week[1, 5] --> this is a range of position one to five</p>

<p>arrays in Ruby are elastic (52 min)</p>

<p>a = [[1, 2], "a"]
a[0] # => [1,2]
a[0][1] => 2</p>

<p>RECEIVERS (55 min)
-Ruby is an object oriented language so that means that everything is an object. We interact with objects by sending them methods using methods</p>

<p>slice(0,2) # => this slices out the first 3 elements
concat("uth") # => this appends "uth" to the end</p>

<p>chomp and slice are out periodic elements (1hr 8 min)</p>

<p>STRING METHODS:
strip gets rid of both leading and trailing spaces
lstrip - rid of leading spaces
tstrip - trailing spaces</p>

<p>puts "of Least Surprise".insert[0, "Principle"] => inserts Principle at position 0</p>

<p>gsub (1hr 16min)- global substitution - takes two arguments (the pattern, the replacement value)</p>

<p>Booleans-
puts"".empty? #=> true
put " ".empty? #=> false</p>

<p>eql?, starts_with?, include?</p>

<p>Return Methods (1hr 18min)-
to_i
size
next --> next thing in a sequence. puts "a".next # => "b"</p>

<p>puts "one, two".slice(0,3) #=> one --> start at position one and give me 3 characters</p>

<p>match --> the first occurance of the match
scan --> scan will return all occurances --> returns an array of objects</p>
]]></content>
  </entry>
  
</feed>
