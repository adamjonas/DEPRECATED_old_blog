<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Documenting all this...]]></title>
  <link href="http://ajonas.herokuapp.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://ajonas.herokuapp.com/"/>
  <updated>2012-09-18T16:20:19-04:00</updated>
  <id>http://ajonas.herokuapp.com/</id>
  <author>
    <name><![CDATA[Adam Jonas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Standard Library]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/09/18/ruby-standard-library/"/>
    <updated>2012-09-18T13:59:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/09/18/ruby-standard-library</id>
    <content type="html"><![CDATA[<p><a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/fileutils/rdoc/FileUtils.html">###FileUtils###</a></p>

<p>The functions mostly involved changing dir, moving, removing, and copying files.</p>

<p>Going to give us different options for working with dir entries and files in the file system.</p>

<p>easy to work with in IRB</p>

<h3>Methods</h3>

<p>.cmp will tell you if two files have the same content
.touch creates a file if it doesn't exist
.cp copy contents to another file</p>

<p><a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/logger/rdoc/Logger.html">###Logger:###</a></p>

<h3>URIs</h3>

<p>URI stands for "Uniform Resource Identifier." The URI module can be used to parse and manipulate URIs in your Ruby programs.</p>

<p>```</p>

<blockquote><p>require 'uri'
 => true
require 'open-uri'
 => true
url = URI.parse('http://teamtreehouse.com/')
 => #&lt;URI::HTTP:0x007f9b728dfda0 URL:http://teamtreehouse.com/>
puts url.inspect</p>

<h1>&lt;URI::HTTP:0x007f9b728dfda0 URL:http://teamtreehouse.com/></h1>

<p> => nil
puts url.hostanme
NoMethodError: undefined method `hostanme' for #&lt;URI::HTTP:0x007f9b728dfda0 URL:http://teamtreehouse.com/></p>

<pre><code>from (irb):10
from /Users/Ajonas/.rvm/rubies/ruby-1.9.3-p194/bin/irb:16:in `&lt;main&gt;'
</code></pre>

<p>puts url.hostname
teamtreehouse.com
 => nil
puts url.path
/
 => nil
puts URI.split('http://teamtreehouse.com').inspect
["http", nil, "teamtreehouse.com", nil, nil, "", nil, nil, nil]
 => nil
google = open('http://google.com').read
=> this outputs the html of the google homepage...
```</p></blockquote>

<h3>Benchmark Module</h3>

<p>Provides methods to report the time used that the program takes to execute...</p>

<p>```ruby Benchmarking symbols vs strings
require 'benchmark'</p>

<p>repetitions = 1000000</p>

<p>Benchmark.bm(7) do |x|</p>

<pre><code>x.report "String" do
    repetitions.times do
        options = { 'hello' =&gt; 'world' }
    end
end

x.report 'Symbol' do
    repetitions.times do
        options = { hello: :world }
    end
end
</code></pre>

<p>end
```</p>

<h3>OptParse Library</h3>

<p>```ruby
require 'ostruct'
require 'optparse'
require 'open-uri'</p>

<p>class MyParser</p>

<pre><code>def self.parse(args)
    options = OpenStruct.new
    opts = OptionParser.new do |opts|
        opts.banner = "Usage: url"

        opts.on('-u', '--url URL', 'Fetches the given url') do |url|
            options.url = url
        end
    end

    begin
        opts.parse!(args)
    rescue Exception =&gt; e
        puts "Exceptions encountered: #{e}"
        puts opts
        exit 1
    end

    options
end
</code></pre>

<p>end</p>

<p>options = MyParser.parse(ARGV)</p>

<p>if options.url</p>

<pre><code>puts open(options.url).read
</code></pre>

<p>end
```</p>

<h3>Observable Library</h3>

<p>The Observable module allows you to easily implement the observer pattern in your classes. The observer pattern specifies that an object maintains a list of its dependents, called observers, and notifies them automatically of any state changes.</p>

<p>You could put this behavior in the classes themselves, but by putting them in an observer class it keeps the classes clean.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Struct]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/09/10/struct/"/>
    <updated>2012-09-10T12:33:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/09/10/struct</id>
    <content type="html"><![CDATA[<p>```ruby Struct
Struct.new("Flatiron", :name, :location)</p>

<p>flatiron = Struct::Flatiron.new
flatiron.name "Flatiron"
flatiron.location = "33 West 26th st"
```</p>

<p><code>ruby Here is another way to do it...
School = Struct.new(:name, :location)
flatiron = School.new("flatiron", "33 west 26th")
</code>
```ruby we can also define a method in the struct
School = Struct.new(:name, :location)</p>

<pre><code>def travel
    puts "going to #{location} location..."
end
</code></pre>

<p>end</p>

<p>flatiron = School.new("flatiron", "33 west 26th")</p>

<p>flatiron.travel
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Bits]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/09/06/ruby-bits/"/>
    <updated>2012-09-06T15:33:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/09/06/ruby-bits</id>
    <content type="html"><![CDATA[<p>||= Assigns if there is not existing value. Otherwise, the previous assigment will override it.
Good way to set defaults if you need them</p>

<p>```ruby Refactoring using ||=
options[:country] = 'us' if options[:country].nil?</p>

<h1>can refactor as</h1>

<p>options[:country] ||= 'us'
```</p>

<p>```ruby Case statement e.g.
def search(games, search_term)
  search_index = case games.find_index(search_term)</p>

<pre><code>  when search_index
     "Game #{search_term} found: #{games[search_index]} at index #{search_index}."
   else
    "Game #{search_term} not found."
  end
</code></pre>

<p>end
games = ["Super Mario Bros.", "Contra", "Metroid", "Mega Man 2"]
puts search(games, "Contra")
```</p>

<p>```ruby Options
def new_game(name, options= {})
  {</p>

<pre><code>name: name,
year: options[:year],
system: options[:system]
</code></pre>

<p>  }
end
game = new_game("Street Figher II",
 year: 1992,
 system: "SNES"
 )
```</p>

<p>rindex- Returns the index of the last occurrence of the given substring or pattern (regexp) in str. Returns nil if not found. If the second parameter is present, it specifies the position in the string to end the searchâ€”characters beyond this point will not be considered.</p>

<p>private methods: all private methods are not accessible for outside objects</p>

<p>```ruby Raising Exceptions
class InvalidGameError &lt; StandardError; end
def new_game(name, options={})
  raise InvalidGameError if name.nil?
  {</p>

<pre><code>name: name,
year: options[:year],
system: options[:system]
</code></pre>

<p>  }
end
begin
  game = new_game(nil)
rescue InvalidGameError => e
  puts "There was a problem creating your new game: #{e.message}"
end
```</p>

<p>```ruby splat arguments
def describe_favorites(*games)
  for game in games</p>

<pre><code>puts "Favorite Game: #{game}"
</code></pre>

<p>  end<br/>
end
describe_favorites('Mario', 'Contra', 'Metroid')
```</p>

<p>```ruby Classes
class Game
  def initialize(name, options={})</p>

<pre><code>@name = name
@system = options[:system]
@year = options[:year]
</code></pre>

<p>  end
end
```</p>

<h3>Encapsulation</h3>

<p>Passing around data and numbers breaks encapsulation
If all you are passing around is data- then an options hash should suffice</p>

<h3>Private / Protected Methods</h3>

<p>Private methods in Ruby cannot be called with an explicit receiver.
```ruby Private
def up_vote(friend)</p>

<h1>in this case, bump karma is private</h1>

<pre><code>bump_karma
#below will error out
friend.bump_karma
</code></pre>

<p>end
```</p>

<p>Protected methods in Ruby CAN be called with an explicit receiver, but not outside the class.
```ruby Protected
def up_vote(friend)</p>

<h1>in this case, bump karma is private</h1>

<pre><code>bump_karma
#below will error out
friend.bump_karma
</code></pre>

<p>end
```</p>

<h3>Inheritance / Super</h3>

<p>A way to DRY up duplication is to use inheritance ot inherit behavior for two classes</p>

<p>Super looks for definitions in the parent class and applies it in the child class</p>

<h3>Active Support</h3>

<p>```ruby
def anniversary(game, years)
  game[:release].advance(years: years)
end</p>

<p>game = {
  name: 'Contra',
  release: DateTime.new(1987, 2, 20, 0, 0, 0)
}
puts anniversary(game, 20)
```</p>

<p>```ruby difference between hashes</p>

<h1>Using ActiveSupport, return the difference between Mario's favorite games and Luigis's favorite games by implementing the difference_between method.</h1>

<p>def difference_between(player1, player2)
  player1.diff(player2)
end
```</p>

<p>when you include something. it is included in the ancestor's class.</p>

<h3>Namespacing</h3>

<p>putting functions in a module will prevent namespacing conflicts
a common pattern is to 'include' the module inside of the class... this will expose the module methods as instances methods in the object -- which means the methods will have access to the object's internal properties.</p>

<p>when use mixin versus classical class inheritance.
A class can only have one super class
inheritance suggests specialization</p>

<p>the extends keyword included as the class methods</p>

<p>use extend to expose class methods as class methods
use include to expose class methods as instance methods</p>

<p>if you call extend on an object, then it exposes the methods as instance methods on an object</p>

<p>```ruby object extend
game = Game.new("Contra")</p>

<h1>extend the Playable module for the specific game object</h1>

<h1>the module is not available to other objects in that class</h1>

<p>game.extend(Playable)
game.play
```</p>

<p>method hooks allows you to both include and extend modules</p>

<p>```ruby
module LibraryUtils</p>

<p>  def add_game(game)
  end</p>

<p>  def remove_game(game)
  end</p>

<h1>this extends the ClassMethods so that it doesn't need to be called below</h1>

<p>  def self.included(base)</p>

<pre><code>base.extend(ClassMethods)
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>def search_by_game_name(name)
end
</code></pre>

<p>  end
end</p>

<p>class AtariLibrary
  include LibraryUtils
  #see-- no extend but still includes the class methods module...
end
```</p>

<h3>Active Support Concern</h3>

<p>this allows us to use the include and extend calls without making it so ugly.</p>

<p>```ruby ActiveSupport Concern
require 'active_support/concern'</p>

<p>module LibraryUtils</p>

<h1>this ensures that the dependencies are properly resolved...</h1>

<p>  extend ActiveSupport::Concern</p>

<p>  def add_game(game)
  end</p>

<p>  def remove_game(game)
  end</p>

<p>  module ClassMethods</p>

<pre><code>def search_by_game_name(name)
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby ActiveSupport Concern
module LibraryLoader</p>

<p>  module ClassMethods</p>

<pre><code>def load_game_list
end
</code></pre>

<p>  end
end</p>

<p>module LibraryUtils</p>

<p>  extend ActiveSupport::Concern</p>

<p>  #included block below is much cleaner
  included do</p>

<pre><code>load_game_list
</code></pre>

<p>  end
end</p>

<p>class AtariLibrary
  include LibraryUtils
end
```
Some more in depth reading to understand this better...
<a href="http://yehudakatz.com/2009/11/12/better-ruby-idioms/">here is an explanation from yehuda katz</a></p>

<p><a href="http://www.fakingfantastic.com/2010/09/20/concerning-yourself-with-active-support-concern/">Concerning Yourself with ActiveSupport::Concern</a></p>

<p>From 2010- <a href="http://www.strictlyuntyped.com/2010/05/tweaking-on-rails-30-2.html">Tweaking on Rails 3.0: #2 ActiveSupport::Concern</a></p>

<h3>Blocks</h3>

<p>```ruby Yields
class Library
  attr_accessor :games</p>

<p>  def initialize(games = [])</p>

<pre><code>self.games = games
</code></pre>

<p>  end</p>

<p>  def each_on_system(system)</p>

<pre><code>games.each do |game| 
#'yield game'yields the game object
  yield game if game.system == system
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby Yields
  def list</p>

<pre><code>games.each do |game|
  puts yield game
end
</code></pre>

<p>  end
```</p>

<p>```ruby
class Game
  attr_accessor :name, :year, :system
  attr_reader :created_at</p>

<p>  def initialize(name, options={})</p>

<pre><code>self.name = name
self.year = options[:year]
self.system = options[:system]
@created_at = Time.now
</code></pre>

<p>  end</p>

<p>  def play</p>

<pre><code>emulate do |emulator|
  emulator.play(self)
end
</code></pre>

<p>  end</p>

<p>  def screenshot</p>

<pre><code>emulate do |emulator|
  emulator.start(self) 
  emulator.screenshot
end
</code></pre>

<p>  end</p>

<p>private</p>

<p>def emulate
  begin
  emulator = Emulator.new(system)
  yield emulator</p>

<pre><code>rescue Exception =&gt; e
  puts "Emulator failed: #{e}"
</code></pre>

<p>  end
end
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Lecture 4]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/07/18/ruby-lecture-4/"/>
    <updated>2012-07-18T19:08:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/07/18/ruby-lecture-4</id>
    <content type="html"><![CDATA[<p>Programmer of the day:
Alan Kay</p>

<h3>Object Orientation</h3>

<p>once you have a user class, you can send it a message
once you have a class you can teach the class how to do things like authenticate a user</p>

<h3>Review</h3>

<p>iteration: going through many things one at a time
we refer to that character one at a time, as the iterator or yield</p>

<p>.inspect allows you to look at an object that</p>

<p>common to have nested iteration-- iterate through them, by looping through enumerables within a loop</p>

<p>Iterating a hash you get yielded two variables at once, the key first and the value second</p>

<p>``` ruby
alphabet = {:a => 1, :b => 2}</p>

<p>alphabet.each do |key, value|
  puts "#{key} is the #{value} letter"
end
```</p>

<p>.compact will get rid of any nil values
.uniq will get rid of duplicates</p>

<p>! methods will change the data set forever...</p>

<p>.flatten will remove nesting from an array-- will flatten all elements in array
.reverse elements in the array</p>

<p>side note: python believes there is one way to do something. Ruby believes there should be many ways to do it so that you can be more expressive.</p>

<p><code>ruby ordinalize is a integer method
1.ordinalize     # =&gt; "1st"
2.ordinalize     # =&gt; "2nd"
1002.ordinalize  # =&gt; "1002nd"
</code></p>

<p>``` ruby multiple_of?(number)</p>

<h1>Check whether the integer is evenly divisible by the argument.</h1>

<p>0.multiple_of?(0)  #=> true
6.multiple_of?(5)  #=> false
10.multiple_of?(2) #=> true
```</p>

<p>Lab solution (8PM)</p>

<p>hash structure with root or without root TODO</p>

<p>.detect, .select and .reject methods are all useful array elements</p>

<p>class CONSTANTS are really good for storing data about the class</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ruby lecture 3]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/07/17/ruby-lecture-3-july-16/"/>
    <updated>2012-07-17T22:50:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/07/17/ruby-lecture-3-july-16</id>
    <content type="html"><![CDATA[<p>Programmer of the day:
Kent Beck</p>

<p>FizzBuzz
solutions on ?ruberque?</p>

<p>TDD: able to write the code that you wish you had</p>

<h3>Array Review:</h3>

<p><code>ruby
empty[0] = "filled" #=&gt; can assign slots one at a time
easy_as[1, 5] #=&gt; can slice elements off, have elastic arrays --&gt; can add elements to an array without doing anything else
</code></p>

<h3>Lecture:</h3>

<p>Object orientation- we send object methods
important to identify who the receiver is and what the method is
part of dot notation: every method returns an object, so you can chain another method on it
it's the return of the previous method that is the receiver for the following method</p>

<p>the strip method is part of the family of normalization</p>

<p>gsub = global substitution
sub will only replace the first occurrence it encounters</p>

<p>== is the same as eql method</p>

<p>methods that end with question marks --> the ? is part of the method name that indicates it returns a boolean value</p>

<p>strings like arrays can be sliced</p>

<p>match accepts a pattern of REGEX
  -the string literal for patterns are /a/e/i/o/u
  -check <a href="http://rubluar.com">http://rubluar.com</a></p>

<p><strong>Iteration</strong> is a fancy word for looping</p>

<p>anything that can iterated upon is described as an <em>enumerable</em>
strings and arrays are enumerables</p>

<p><strong>Scope</strong></p>

<p>scope gates -- every time you see a 'do', 'end', 'def' keyword your scope changed.</p>

<p>blocks have an exclusive scope. If it is defined in that block and only in that block it is accessible for the outside.
method scopes are even stricter. cannot access method outside of that particular method.
parameters are how you pass in values into a method.</p>

<p>2nd program- (8:25- 8:35)
artist, album, song sorting</p>

<p><em>first step in a program is usually to set up state</em></p>

<p><strong>More Data Types</strong>
<em>Hashes</em> a lot like an array in that it is a collection object. An array is only indexed, so you can only refer to the objects within the array by its position</p>

<p><em>Literal Constructors:</em></p>

<p>"" - strings</p>

<p>/ - REGEX</p>

<p>[] - array</p>

<p>{} - hashes</p>

<p>: - symbols</p>

<p>Hashes are valuable when you care about the meta data</p>

<p>every time you create a new string, it creates a new object in memory
a symbol is an immutable object
``` ruby
vending machine {</p>

<pre><code>a: =&gt; ["snickers", "twix", "kit kat"]
</code></pre>

<p>}
puts vending_machine[:a][0] #=> this accesses the :a key and the 0th position of the array which is the value
```</p>
]]></content>
  </entry>
  
</feed>
