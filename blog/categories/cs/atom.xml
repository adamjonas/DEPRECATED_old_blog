<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cs | Hack hack hack...]]></title>
  <link href="http://adamjonas.com/blog/categories/cs/atom.xml" rel="self"/>
  <link href="http://adamjonas.com/"/>
  <updated>2016-05-02T17:09:11-04:00</updated>
  <id>http://adamjonas.com/</id>
  <author>
    <name><![CDATA[Adam Jonas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Computer Science according to Spencer]]></title>
    <link href="http://adamjonas.com/blog/computer-science-according-to-spencer/"/>
    <updated>2016-04-27T13:07:00-04:00</updated>
    <id>http://adamjonas.com/blog/computer-science-according-to-spencer</id>
    <content type="html"><![CDATA[<h2>What is it</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/1062811/difference-between-a-computer-scientist-and-computer-programmer">cs versus programming</a></li>
</ul>


<h2>Big O</h2>

<ul>
<li>used to classify algorithms by changes to the inputs</li>
<li>O(1) - constant time - kilometers to millimeters</li>
<li>O(log n) - opposite of exponential growth, searching binary tree</li>
<li>O(n) - iterating over an array</li>
<li>O(n log n) - good sorting algorithms</li>
<li>O(n<sup>2)</sup> - bubble sort (bad algoritms)</li>
<li>O(2<sup>n)</sup> - the chess board, example doubling something</li>
</ul>


<h2>Exercises</h2>

<p>```java
  1.
  int rectangle_area(height, width) {</p>

<pre><code>int area = 0; // 1

for(int i = 0; i &lt; height; i++) { // 2*height + 1
  for(int j = 0; j &lt; width; i++) { // 2*height*width + height
    area++; // height*width
  }
}

return area; // 1
</code></pre>

<p>  }</p>

<p>  complexity: 3<em>height</em>width + 2<em>height + 3
  order: O(height</em>width)</p>

<ol>
<li></li>
</ol>


<p>  Constant time. O(1).</p>

<ol>
<li><p>int halves(n) {
int count = 0; // 1</p>

<p>if(n % 2 == 1) { // n
  n = n - 1; // n
}</p>

<p>for(int i = n; i > 1; i = i / 2;) { // n + n + n
  count++; // n
}</p>

<p>return count; // 1
}</p></li>
</ol>


<p>  Complexity: 6n + 2
  Order O(log n)</p>

<ol>
<li><p>int bacteria_generation(days) {
int total_population = 1; // 1
int current_population = total_population; // 1</p></li>
</ol>


<pre><code>for(int i = 0; i &lt; days; i++) { // 1 + days - 1 + days - 1
  current_population = total_population; // days - 1

  for(int j = 0; j &lt; current_population; j++) { 
    total_population++;
  }
}

return total_population;
</code></pre>

<p>  }</p>

<p>  Order: O(2n)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memory Pointers]]></title>
    <link href="http://adamjonas.com/blog/memory-pointers/"/>
    <updated>2016-01-28T13:54:00-05:00</updated>
    <id>http://adamjonas.com/blog/memory-pointers</id>
    <content type="html"><![CDATA[<h3>Random notes from code reading</h3>

<ul>
<li><p>with 64-bit pointers</p></li>
<li><p>poro -> an array, for example, is made multiple times. One with items
of the array, again for indexes of the array, etc.</p></li>
<li><p>memory swap -> linked lists</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree</a></p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Sparse_array">sparse array</a></p></li>
<li><p>program restart re-allocates the memory</p></li>
<li></li>
</ul>

]]></content>
  </entry>
  
</feed>
